---
author: Quincy Larson
authorTwitter: https://twitter.com/ossia
authorFacebook: https://facebook.com/10100956570023241
title: "A Cautionary Tale of Learning to Code. My own."
subTitle: "I was just a guy in a suit in an office with a vague startup idea. Then I decided to learn to code...."
coverSrc: https://cdn-images-1.medium.com/max/2000/1*r7Zo59f6Zoy65GwVioQqug.jpeg
url: https://medium.freecodecamp.org/a-cautionary-tale-of-learning-to-code-my-own-eddb24d9d5a7
id: a-cautionary-tale-of-learning-to-code-my-own-eddb24d9d5a7
date: 2014-11-14T00:00:00.000Z
tags: [
  "Education",
  "Technology",
  "Design",
  "Self Improvement",
  "Learning"
]
---
# A Cautionary Tale of Learning to Code. My¬†own.







![](https://cdn-images-1.medium.com/max/2000/1*r7Zo59f6Zoy65GwVioQqug.jpeg)







I was just a guy in a suit in an office with a vague startup idea. Then I decided to learn to code.

I overheard some guy at a happy hour bragging about how easily he was able to automate his office workflows by using a language called Ruby. I thought, ‚Äúhuh, Ruby.‚Äù I went home, googled it, and within 15 seconds, I was working through a random Ruby tutorial.

A week later, I went to my first hackerspace meeting. Everyone was talking about languages like Scala, Clojure and Go. There was so much to learn. I borrowed three O‚Äôreilly books and got about 50 pages into each of them.



![](https://cdn-images-1.medium.com/max/1600/0*F0oiYxIaYLBKwKor.jpg)

Most technical books start off nice and easy before making big assumptions about your prior knowledge.



A friend told me I should get good at Emacs, and gave me his configuration files. I spent a few hours learning basic Lisp syntax so I could further configure it.

Then some guy walked by and saw me using Emacs. ‚ÄúWhy are you using Emacs?‚Äù he asked me. ‚ÄúDon‚Äôt you know Vim is better?‚Äù ‚ÄúHm. Vim.‚Äù So I started memorizing dozens of Vim keyboard shortcuts.



![](https://cdn-images-1.medium.com/max/1600/0*8Of4fgUMVCYvXzOD.png)

Most arguments about text editors are what engineers call ‚Äúreligious wars‚Äù‚Ää‚Äî‚Äärooted more in historical differences than practical merit.



At the time, it seemed reasonable to think that the faster I could type, the faster I could code. I switched to a Programmer‚Äôs Dvorak keyboard layout because, hey, it was objectively the most efficient keyboard a programmer could use.



![](https://cdn-images-1.medium.com/max/1600/0*CxBvoOOrnTbG-jrp.png)

Can you count how many letters, numbers and symbols are in their original Qwerty positions? I‚Äôll give you a hint‚Ää‚Äî‚Ääit‚Äôs in the low single¬†digits.



On the days I could actually get my netbook to successfully boot Linux‚Ää‚Äî‚Ääand that I was able to type more than 10 words per minute‚Ää‚Äî‚ÄäI studied Python by working through books and Udacity courses.

After 7 months of grueling self-study and going to coding events, I landed my first software engineer job.

During my interview with the CTO, I told him about all the tools I‚Äôd learned and the esoteric configurations I was using. The CTO nodded and listened politely. And once I‚Äôd finished boasting of the breadth of my knowledge, he put me in my place with a single polite observation. He said, ‚ÄúThere are many ways you can do most things, but only a few ways that make sense.‚Äù With that, he handed me a beat-up MacBook and set me loose in the developer bullpen.

Four years before, the company had decided to build their product using Ruby on Rails. They committed fully to that decision, and much of their original code was still intact. All the engineers used MacBooks, which were both reliable and similar to the Ubuntu Linux servers they used in production.

Instead of arguing over Vim or Emacs, everyone just used RubyMine, a powerful Integrated Development Environment (IDE) with a sensible default configuration. This meant that any one engineer could sit down next to any other engineer and immediately start pair programming on a task without needing to orient themselves to their colleague‚Äôs development environment. This fact alone solved much of the awkwardness and unconscious resistance two developers feel when they try to collaborate.

The company was OK with me not knowing Ruby on Rails. Since I‚Äôd focused my studies enough to learn some Python and Django and win a hackathon, they took that as a sign that I could eventually learn Rails.

The first few weeks were tough, and not just because I was working with a new team in a new language, framework and codebase. It was tough because everywhere I looked, I saw evidence that I‚Äôd gone about learning to code in an absurdly masochistic way.

I‚Äôd spent months sitting alone in libraries and cafes, blindly installing tools from the command line, debugging Linux driver problems, and banging my head over things as trivial as missing parenthesis.

I dabbled in every online course program imaginable, and started countless MOOCs. I don‚Äôt think I actually got something onto the internet without the guidance of a tutorial until month number five!

This gave me the impression that programming was a Sisyphean struggle. I was convinced that the seemingly normal programmers I ran into were actually sociopaths who had experienced, then repressed, the trauma of learning to code.



![](https://cdn-images-1.medium.com/max/1600/0*ksAF0A99qrP8GOII.jpg)

I snapped this selfie the Saturday morning after my last day at my corporate job. I got up early and dressed in a suit to reinforce the seriousness of the task at hand: I was going to learn to code! Facebook caption: ‚ÄúMy new office‚Ää‚Äî‚Ääthe kitchen table! I clock in here every morning at 8 and until 6, I only get up for ‚Äúbio-breaks‚Äù.‚Äù Note the use of quotes around the term bio-break. I was trying to be cute and talk like a programmer. I now catch myself using this term daily, without¬†irony.



Contrast this with my coworkers, who rarely even encountered syntax errors because their IDEs caught them first. My coworkers‚Äô MacBooks just worked. If they got an error message and couldn‚Äôt solve it with a few minutes of reading and googling, they‚Äôd simply instant message one another for help debugging it. They‚Äôd hop over to one another‚Äôs desks and casually pair program.

There wasn‚Äôt much ego or elitism. There wasn‚Äôt the feeling that programming was a grind. It was just a series of constructive conversations between friendly adults, several of whom had learned to code on their own like I had.

The team was committed to their tools. Aside from Passion Project days and hackathons where developers could experiment with new JavaScript frameworks like Angular.js, they mostly focused on getting better with their current technology. They were conservative about what they allowed into their codebase.

You see this same ethos at places like [ThoughtBot](http://playbook.thoughtbot.com/), where everybody sticks with a small but effective tool chain (in their case, Rails, Vim, Postgres and Redis). By focusing on a few key tools, their engineers become experts who can easily interoperate.

So the real questions is, if highly productive teams of software engineers work best with a focused set of tools, couldn‚Äôt people learning to program also learn best with a focused set of tools? Online coding curricula and coding bootcamps certainly seem to think so.

But as an individual, with so many options out there, it‚Äôs really hard to decide what to learn. I know because I was that dog circling around an intersection, chasing one car after another. A good programmer‚Äôs skill set can be described as T-shaped, with shallow knowledge in many areas, but deep knowledge in at least one. But after months of stress and hard work, I was shaped more like an underscore.

For each person I‚Äôve met who started out learning this way‚Ää‚Äî‚Ääand I‚Äôve met many‚Ää‚Äî‚Ääthere are probably countless people who started out this way, got discouraged, and gave up their dreams of being a programmer. I don‚Äôt want this to happen to you.

### You need to¬†focus



![](https://cdn-images-1.medium.com/max/1600/1*QQXBnqz3RrvlySiBew5b9g.jpeg)



Without further ado, here the big mistakes I see new coders make all the time:

*   Switching languages or frameworks frequently, or deluding themselves into thinking they can become proficient in all of them.
*   Personalizing their development environment with exotic tools, rather than more conventional tools that can be reliably used while collaborating with others.
*   Trying to learn tools like Docker and Famo.us because they‚Äôre new and exciting, even though they haven‚Äôt yet mastered more fundamental technologies.

If I had to summarize my do-as-I-say-not-as-did advice in one word, it would be: **focus**.

My question to you is: would you describe your plans for learning to code as focused? If you feel your plans are focused, you should stop reading now and get back to studying, because I don‚Äôt want to say something that might cause you to lose focus. If you haven‚Äôt focused your plans for learning to code yet, I have good news‚Ää‚Äî‚Ääyou can do this right now. But it will take a few minutes and involve making some hard decisions. Wait! Don‚Äôt leaaaaave‚Ä¶ Oh, good. You‚Äôre still here. OK, here are the decisions you need to make:

1.  Choose **one** type of software development that interests you enough to define your career: web, mobile, gaming or embedded. I recommend web because it‚Äôs flexible. There are a ton of jobs and a ton of learning resources. If you‚Äôre passionate about something other than web development, leave this blog post and google search ‚Äúgetting started in _____ development‚Äù and go all-in on it!
2.  Choose **one** language to learn: JavaScript, Ruby, or Python. Each has its strengths. Each has tools that can be used to build web apps (Node.js, Rails, and Django respectively). Unless you already have a strong preference, I recommend JavaScript because it‚Äôs the most popular language.
3.  Choose **one** online curriculum to study. Here are the some comprehensive options: [Free Code Camp](http://freecodecamp.com/) for JavaScript and [The Odin Project](http://theodinproject.com/) for Ruby. Trust the wisdom of the teachers who designed the curriculum you‚Äôve chosen, and work through it in the recommended order, without skipping around.

Once you‚Äôve made these decisions, the path forward is simple. Keep your sanity by ignoring the hype surrounding new tools. Keep your momentum by working through your chosen curriculum seven days a week, even if it‚Äôs only for half an hour at a time. Keep your confidence by trusting the judgement you made with today‚Äôs decisions.

And remember: with patience, any able-minded person can become a great coder, and that includes you.

_If you liked this, click theüíö below. Follow me and Free Code Camp for more articles on technology._



![](https://cdn-images-1.medium.com/max/1600/1*31StU5CNIHk8VDkSHWO6nA.gif)










